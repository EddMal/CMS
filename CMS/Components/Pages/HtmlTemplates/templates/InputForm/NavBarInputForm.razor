@using CMS.Components.Pages.HtmlTemplates.templates
@using CMS.Data;
@using CMS.Entities;
@using Microsoft.AspNetCore.Components;
@using Microsoft.EntityFrameworkCore;
@using System.Threading.Tasks;

@namespace Templates.InputForm

<h3>Input Form</h3>

<div>
@*  Patrik, för att förklara lite hur jag gick tillväga för att ha ett input field för samtliga: inputValue, inputValue1 och inputValue2.
    Gjorde en loop (kan vara switch case med) som håller reda på vilken av de tre ovan som är den aktuella för inputen vid ett givet tillfälle.
    Anledningen var att det är ser mer cleant ut att ha endast ett fält med tillhörande knapp än att alltid visa flera fält varav ett alltid är tomt.
    GetPlaceholderText() lade jag till så det inte gav intrycket att man måste ha två olika textinputs, ingen aning om det är något du vill behålla.
    Done() är en knapp med tillhörade funtion som tar användare till "/content". Mer info längre ned i texten.
    Jag tror inte jag ändrade så mycket mer, eventuellt till async Task i någon fil men nu börjar jag snart blanda ihop allt själv (din kod).
    Så det är endast denna filen som är totalt ändrad. Men nu sparar den korrekt i Db, och preview fungerar.
    /Jens
*@

    @{if (currentStep == InputStep.ContentNameInput)
    {
                  
        <form>
            <div>
                    <label for="templateDropdown">Meny namn:</label>
                <input type="text" @bind="inputValue" placeholder="" />
                <button type="button" @onclick="HandleSubmit">Lägg till</button>
            </div>
        </form>
    }
    else
    {
            

        <div>
            <label for="templateDropdown">Lägg till sida:</label>
                <select id="templateDropdown" @onchange="HandleSubmit">
                <option value="">-- Välj Sida --</option>
                    @if (webpages != null)
                {
                        @foreach (var item in MenyItems)
                    {
                        <option value="@item.Value">@item.Key</option>
                    }
                }

            </select>
            <button type="button" @onclick="HandleSubmit">Spara</button>
            <button type="button" @onclick="AddSubmit">Lägg till menylänk.</button>
        </div>
        }

        @* <div>
            <label>@currentLabelText</label>
            <input type="text" @bind="inputValue" placeholder="" />
            <button type="button" @onclick="HandleSubmit">Edit</button>
        </div> *@
    }

    <div>
        <BackgroundColorSelector @bind-SelectedColor="Backgroundcolor" />
        <br>
        <TextColorSelector @bind-SelectedTextColor="Textcolor" />
    </div>

    <div style="margin-top: 10px;">
        <button type="button" @onclick="Done">Done</button>
@*  Eftersom vi nu (enligt Mikael borde) sparar direkt i Db när ett textfält läggs till så tog jag bort min Cancel kod nedan.
    Det vi kan göra är att ladda templaten och sparar över det man redan tryck igenom om man trycker på cancel, eftersom koden blir nu automatiskt sparad direkt man trycker på Add (vilket sker efter varje textinput).
    Jag påbörjade men slutade och rullade tillbaka försök att få rullningsmenyn över färger att automatiskt uppdateras dynamiskt så som input av texter fungerar.
    Det blev för bökigt och det är redan rörigt i mitt huvud eftersom det är kod jag inte skapat från början :)
    
    <span style="margin-left: 10px;"></span>
    <button type="button" @onclick="CancelTemplate">Cancel</button> *@
    </div>
</div>


